---
title: "SoRUI #1 - The State of Rust Text Rendering 2024"
date: 11 Aug 2024
description: ' '
tags: ['rust', 'ui', 'text', 'fonts']
published: false
---

This post is the first in a new series of "State of Rust UI" (SoRUI) blog posts. Each post in the series focusses on a different theme with Rust UI. The theme of this post is text rendering.

<small>Readers of this article may also be interested in this [State of Text Rendering 2024](https://behdad.org/text2024/) article by Behdad Esfahbod (HarfBuzz maintainer) which covers recent developments in text rendering more widely but has less detail about the state of the Rust ecosystem specifically.</small>

## Understanding The Modern Text Rendering Pipeline

Text rendering is surprisingly complex.

In 2024 it isn't sufficient to only handle Latin scripts (let alone only ASCII text). We need to handle Arabic that runs right-to-left rather than left-to-right. We need to handle Chinese and Japanese scripts which can be run vertically as well as horizontally. We need to handle Indic scripts which have complex rules for reordering glpyhs.

We also need to be able to handle arbitrary combinations of such scripts (potentially mixing multiple fonts and writing directions), with emoji which also typically come with their own dedicated fonts (for which there are several competing formats in mainstream use). We need to handle ligatures. We need to deal with variable fonts. The list goes on.

A modern text rendering pipeline involves roughly the following steps:

* **Font Parsing** Parsing of font formats. Most fonts use the OpenType format. However, OpenType is really a meta/container format that may contain several different "tables" (which may contain arbitrary binary data), each identified by a 4-byte tag. In order to fully support a modern text stack you need to be able to parse not only the tradtional tables representing TrueType font data, hinting and ligatures, but also tables representing Apple's AAT fonts (and their different hinting format), and several emoji formats (at least COLRv0, COLRv1, sbix, and CBDT/CBLC).
* **Font enumeration** is listing (enumerating) all the fonts installed on the system. And collecting metadata about those fonts, for example whether they are serif, sans-serif, monospace, their weight, the code points they cover, etc. Such libraries will typically also load the full font into memory as required (often using mmap).
* **Font fallback** is matching runs of text to a font. This is necessary because fonts typically don't cover the entire unicode range: you have different fonts for latin text, chinese text, arabic text, etc and also usually a separate font for emoji. But if you have say arabic text or emoji embedded within latin text you don't typically specify the font for the arabic text or the emoji, one is chosen for you. That process is font fallback.
* **Clustering** is the combining unicode code points into "shaping clusters" in preparation for shaping. [Shaping clusters](https://harfbuzz.github.io/clusters.html) are distinct from [Grapheme Clusters](https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries) and are generally (always?) made up of 1 or more grapheme clusters. Clustering and font-fallback are often closely coupled with shaping in current implementations (e.g. Harfbuzz), but future implementations may be able to decouple them.
* **Shaping** means mapping runs of unicode codepoints (shaping clusters) to specific glyphs within fonts. This includes simple mappings like mapping the "a" character to the appropriate "a" glyph, but also involves things like applying ligatures and resolving emoji modifiers. Some scripts (notably some Indic scripts) require much more complex transformations that involve reordering characters within a cluster.
* **Layout** is computing x/y coordinates for each glyph in a string of text. This includes things like determining a glyph's size (and the appropriate offset for that glyph relative to the previous glyph), line breaking, and bidi reordering. It can also includes more advanced capabilities such as mixed media layout (placing images or other boxes inline with text), laying out around excluded areas, floated boxes. And even things like following an arbitrary vector path.
* **Scaling** is taking the vector outlines of a glyph from the font file and scaling them to the correct size according to the font size being used. These outlines are often then further adjusted by a **Hinting** algorithm that applies fine tweaks.
* **Rasterisation** converts the scaled and hinted vector outlines into a raster bitmap of pixels. Scaling and hinting are sometimes treated as part of "rasterisation" but in this article we will treat these as separate processes. As this process is relatively computationally expensive and is repeated many times (for the same glyph, both within a scene and accross frames), efficient rasterisation can also involve a system for caching the rasterised glyphs.

While not strictly part of *rendering* text. Most text systems will also require:

* **Text Selection** is the ability to mark text as selected. Text should generally be selectable by clicking and dragging the mouse, by using various standard keyboard shortcuts, and via accessibility APIs.
* **Text Input/Editing** is the ability for the user to manipulate text. This requires responding to keyboard input and ensuring that the text is altered appropriately. It also requires interacting with system Input Methods (IMEs). Similar to layout, advanced text editing controls may need to deal with editing rich text and/or mixed media.

Bonus: subsetting

## Key Projects & Organisations in the Rust Text Ecosystem

### Servo

[Servo](https://servo.org/) is an experimental web browser written in Rust. It was one of the first Rust projects needing high-quality text rendering support. As the Rust ecosystem was not nearly as strong as it is today so, the approach they have taken was mostly to bind to pre-existing C libraries.

Key crates: [rust-harfbuzz](https://github.com/servo/rust-harfbuzz) (parsing/shaping), [rust-freetype](https://github.com/servo/rust-freetype) (parsing/scaling/hinting), [wr_glyph_rasterizer](https://github.com/servo/webrender/tree/main/wr_glyph_rasterizer)/[webrender](https://github.com/servo/webrender) (rasterisation).

### Resvg

The [Resvg](https://github.com/RazrFalcon/resvg) by Yevhenii Reizner ([@RazrFalcon](https://github.com/RazrFalcon)) is another Rust project which has spawned a very impressive set of text-rendering crates. These crates are generally high-quality. They are also all pure Rust. Although they unfortunately suffer from limited development resources and a low [bus factor](https://en.wikipedia.org/wiki/Bus_factor) due to most of the work being done by Yevhenii.

Key crates: [ttf-parser](https://github.com/RazrFalcon/ttf-parser) (parsing), [rustybuzz](https://github.com/RazrFalcon/rustybuzz) (shaping), [fontdb](https://github.com/RazrFalcon/fontdb) (enumeration/database), [tiny-skia](https://github.com/RazrFalcon/tiny-skia) (rasterisation)

### Typst

[Typst](https://github.com/typst/typst) is a new typesetting similar to LaTeX. They have their own layout library (but it isn't designed to be consumed standalone), however some of their developers (notably Laurenz Stampfl ([@LaurenzV](https://github.com/LaurenzV))) have been contributing to the resvg stack of crates.

### System76

[System76](https://system76.com/) and in particuarly Jeremy Soller (@jackpot51)[https://github.com/jackpot51] have built high-level text layout, selection and editing functionality as part of their [cosmic desktop enviroment](https://system76.com/cosmic).

Key crates: [cosmic-text](https://github.com/pop-os/cosmic-text) (layout/selection/editing)

### Linebender

[Linebender](https://linebender.org) is an open-source collective focussed on creating tools for 2D graphics and user interfaces in Rust. Linebender as an organisation has a lot of expertise in text, being started by [Raph Levien](https://levien.com/) [@raphlinus](https://github.com/raphlinus) who currently works at Google Fonts previously maintained Android's text stack and designed the [Inconsolata fonts](https://levien.com/type/myfonts/inconsolata.html), and having attracted a number of other contributors who also have deep expertise in text.

Key crates: [Swash](https://github.com/dfrg/swash) (parsing/shaping/scaling/hinting), [Fontique](https://github.com/linebender/parley/tree/main/fontique) (enumeration/loading), [Parley](https://github.com/linebender/parley) (layout/selection/editing)


### Google Fonts

The Google Fonts organisation within Google (who share a number of members with Linebender) and have a number of very exciting projects in the Rust text space under the [Fontations](https://github.com/googlefonts/fontations) project.

They are currently making strong progress on [Skrifa](https://github.com/googlefonts/fontations/tree/main/skrifa), a pure Rust parser/scaling/hinter, which is [already shipping in Chrome Canary](https://groups.google.com/a/chromium.org/g/blink-dev/c/4xUt73fxCrU) and is actively being pursued as a complete replacement for FreeType in Chrome.

They have also recently started exploring [Harfruzz](https://github.com/harfbuzz/harfruzz), a fork of Rustybuzz refactored to use their `read-fonts` crate instead of `ttf_parser` as the low-level parsing crate, and with the aim bring it up to quality level such that it could replace Harfbuzz in Chrome (funding for this project is not yet confirmed, and would probably be deferred until work on Skrifa is more complete).

Key crates: read-fonts, write-fonts, skrifa (all in the [fontations repo](https://github.com/googlefonts/fontations/tree/main/skrifa))), [harfruzz](https://github.com/harfbuzz/harfruzz).


### Other (Honourable Mentions)

- [YesLogic](https://yeslogic.com/) have published the [AllSorts](https://github.com/yeslogic/allsorts) shaping library which is used in their flagship [Prince](https://www.princexml.com/) HTML to PDF conversion product. It is impressive, however it has not been widely adopted in the Rust UI ecosystem, perhaps because it is not particuarly focussed on performance which is very important for UI usecases (but less critical for document rendering).
- The [ab_glyph](https://github.com/alexheretic/ab-glyph) and [glyph-brush](https://github.com/alexheretic/glyph-brush) collectively make up a complete text-rendering pipeline. However they do so naively, skipping things like shaping, bidi, and more complex layout. They are thus useful if your needs are simple, but cannot be considered a high-quality solution.
- [Fontdue](https://github.com/mooman219/fontdue) is a decent rasterizer with good performance, but is now unmaintained and has been suceeded by newer more complete renderers.
- [Makepad](https://github.com/makepad/makepad/) have their own text stack which is reasonably capable. As usual with Makepad, it is very lightweight, but it is not really designed for 3rd-party consumption. However, their SDF renderer is worth calling out as nothing else in the ecosystem really does it the way they do it. SDF rendering cannot generally attain "gold standard" rendering quality, especially on lower resolution screens, however where SDF rendering is appropriate (games engines, animated text, etc), this solution may well be worthy of study.
- [Skia-Safe](https://github.com/rust-skia/rust-skia) provides excellent bindings to Skia. This can be used both as a rasterizer for a rust-based text stack, and as a full text-stack in it's own right using Skia's `SkParagraph` and other text APIs. This is perhaps less exciting than the promise of an all-new pure-rust text stack, but it is a pragmatic option for high quality text rendering (and general rendering) that is available today.

## Platform Text Stacks

One approach to text is to use the platform's built-in libraries: DirectWrite on windows, CoreText on macOS/iOS, and FreeType on Linux/Android.

The key advantage of this approach is that it allows text to be rendered such that it exactly matches the way that "actually native" applications of that platform (Win32/WPF/AppKit/SwiftUI/etc). The disadvantage is that this constrains you to the lowest-common denominator of the functionaly provided by these APIs, which often be quite limiting. It also requires

TODO: is it possible to use system rasterisation without shaping? (yes: browsers do this).
TODO: Limitation around font loading with system rasterisation (only applies to CoreText?)



### Unicode text handling

Rust, being a new language, is at an advantage in that it's standard library types (such as `String`) represent text as UTF-8. So basic text storage and processing is covered.

However, there are a number of more specific unicode handling routines and algorithms (normalization, segmentation, etc) that are not included in `std` that require an external library. There are two main sets of crates for this in the Rust ecosystem:

- The `unicode-*` crates. These were some of the earlier unicode handling crates in Rust and are widely used.
- The `icu4x` crates. These are a official Unicode Consortium project.

There is also `xi-unicode`, but it is effectively in maintenance mode, with the linebender organisation who created it looking to move to the `icu4x` crates.

In general the `icu4x` crates are more correct/complete, but the `unicode-*` crates are still pretty good and may be faster / more lightweight. For example, the `icu_segmentation` crate offers dictionary-based word segmentation for the Thai language (which doesn't seperate words using spaces) which is important for segmenting Thai but comes at the cost of including the dictionary data. It also offers customisations for different CSS line-breaking modes. Whereas `unicode-segmentation` doesn't offer either of these options but does otherwise correctly implement the unicode segmentation algorithms.

I would suggest defaulting to the icu crates. 

### Font Parsing

If you are using higher-level text libraries then you may not have much choice in which low-level parsing library is used as the higher-level libraries are generally coupled to a specific parsing library. However, you may need to pick one if you are interacting with fonts at a low level.

Knowing about the low-level parsing libraries may be useful when evaluating which set of high-level libraries to use. In particular, you may wish to pick a set of libraries that all depend on the same low-level libraries to avoid bloating your build times and binary size.

The C libraries Freetype and and Harfbuzz both have comphrensive support for parsing OpenType fonts, and these are definitely viable options for font parsing in Rust, with high quality bindings maintained by the Servo project available ([rust-harfbuzz](https://github.com/servo/rust-harfbuzz) and [rust-freetype](https://github.com/servo/rust-freetype)). However they have all of the usual disadvantages of C libraries including the possibility of memory vulnerabilities and unergonomic APIs, and with high-quality pure-rust options available there is little reason to use them unless you are need some of their other capabilities.

The pure-rust parsing libraries are:

- [ttf-parser](https://github.com/RazrFalcon/ttf-parser) is a mature, performant, hand-written parser that has excellent support for the majority of OpenType tables including emoji tables such as CAPL/COLR and sbix, and variable font tables like AVAR (TODO: check tables). 
- read-fonts/skrifa is a new project which uses code generation to generate the parsing code for each table. It also has wide

([Swash](https://github.com/dfrg/swash) also has it's own font parsing code. But this part of Swash has been deprecated in favour of read-fonts/skrifa so it can be discounted for new projects)


TODO:comparison used LaurenzV's writeup.
https://github.com/googlefonts/fontations/issues/956#issuecomment-2226327930
- Both libraries are excellent with little technically separate them at this point.
- Skrifa more equiv to ttf_parser than just read-fonts
- ttf_parser has better table coverage (AAT), but Skrifa rapidly catching up
- Skrifa has more development momentum (inclusion into Chrome + associated maintainance)
- Fontations also has write-fonts.

**Recommendation:** ttf_parser or read-fonts+skrifa depending on which the higher-level libraries you want to use depend on.

TODO: System libs?


### Font Databases: Enumeration, Loading & Querying

There are 3 main crates which do font enumeration in the Rust ecosystem:

- font-kit
- fontdb
- fontique

Font-kit is different from the other two in that it allows fonts to be loaded as handles to the system libraries' (DirectWrite, CoreText and Freetype) native font representations.

Both `fontdb` and `fontique` have standardised on `Arc<dyn AsRef<[u8]> + Send + Sync>` as the underyling type for raw font data. Which (in both cases) is backed by either a memory mapped file (for system fonts) or a `Vec<u8>` if in-memory font data is loaded by the user. And more than any other part of the ecosystem these libraries are excellent candidates for a merging of projects.

The main differences between the two libraries are:

The font enumeration methods:

- Fontdb uses simple filesystem scanning with hardcoded directories. This has the advantage of being simple and lightweight, but the disadvantage of being incompatible with what other appplications on a user's system do which can lead to fonts not being picked up. 
- Fontique hooks into the system-provided mechanisms for enumeration, falling back to scanning where these are inadequate or not available. This has the advantage of matching system norms at the cost of having to depend on relatively heavy system libraries.

And the underlying font parsing library:

- Fontdb uses `ttf_parser`.
- Fontique uses `read_fonts`+`skrifa`

However, it should be relatively easy to merge the enumeration methods by implementing a superset and making use of feature-flagging to allow end-users to make their own trade-offs regarding dependency weight and enumeration fidelity.

Regarding the font parsing library, ideally there should only be one. However, neither library's use of font parsing is that widespread, so it came to it then this could also be abstracted into feature-flagged backends.

The motivation for enacting a merge is interoperability. Many text/font-related activities can be performed independently (so it would be relatively easy for the ecosystem to support multiple options that could be mixed and matches). However, they almost all require a database of fonts and that database really ought to be a global resource that is only loaded once to keep memory usage low. And a single, agreed-upon font database library would make interoperability between the various libraries much smoother.

### Clustering, Shaping & Fallback

- Harfbuzz
- Rustybuzz
- Harfruzz
- Swash
- Allsorts

### Layout, Selection & Editing

- Cosmic-Text
- Parley
- (+ something (winit?) for IME)

### Scaling & Hinting

There are only two pure-rust solutions for scaling/hinting: Swash and Skrifa.

From a technical perspective, Swash is currently slightly more complete with Skrifa not supporting as many emoji formats. Swash also includes (optional) built-in rasterisation. However, Skrifa is actively implementing the missing emoji formats, integrating it with a rasteriser is not hard (and may well be something you need to do anyway if you don't want to use Swash's rasteriser), the scaling part of Skrifa is more correct and better tested code, and the Skrifa has much better hinting support (including freetype-compatible autohinting).

But perhaps the more important factor in choosing between the two is that Swash is in maintenance with all further development effort (except critical bug fixes) from it's author Chad Brokaw being put into Skrifa, which is being actively developed with funding from Google for inclusion in Chromium (and as such is all-but guaranteed to be supported long-term).

**Recommendation**: Swash in the short-term (next ~6 months) for better emoji support, otherwise Skrifa.**

Let us compare each of these options by pipeline stage:

### Rasterisation

Rasterisation is quite different to other pipeline stages in that there are many different viable options, and you can mostly mix-and-match them with the other parts of your text stack. This is because once you scaled and hinted the font outlines they end up being a generic vector format (or something raster format in the case of glyphs from bitmap emoji fonts).

- System libs: wr_glyph_rasterizer
- Freetype
- Swash/Zeno
- Skrifa
- Path rasteriser:
  - Tiny-Skia
  - Vello
  - Skia
  - Etc

## What should I use today?

As a high-level solution you really have 2 choices (unless you want to build your own out of components):

1. **The Cosmic Text stack**:
  - `unicode-*` crates for unicode handling
  - `ttf_parser` for font parsing
  - `fontdb` as a font-database that does font-enumeration
  - `rustybuzz` for shaping
  - `cosmic-text` for layout, selection, and editing (+font-fallback on top of `fontdb`)
  - `swash` for scaling/hinting
  - You can then mix and match any rasterizer (more on this below)
2. **The Parley stack**:
  - Currently `xi-unicode` and `swash` for unicode handling. But planning to switch to `icu4x` crates.
  - `read-fonts`+`skrifa` for font parsing
  - `fontique` as a font-database that does font-enumeration
  - `swash` for shaping
  - `parley` for layout, selection, and editing (+font-fallback on top of `fontdb`)
  - `swash` or `skrifa` for scaling/hinting
  - You can then mix and match any rasterizer (more on this below)

The key differences are:

- Cosmic-Text uses RustyBuzz for shaping and Parley uses Swash. While Swash is much faster, RustyBuzz is a clear winner here from a quality point of view, which Swash having poor support for Indic scripts. However, Parley will likely soon switch to Harfruzz, which will make this a moot point.
- Parley has better support for rich text and mixed media layout. Cosmic-Text only recently added support for paragraphs of text with mixed font sizes and still [has bugs](https://github.com/pop-os/cosmic-text/issues/290) with this feature. Parley has good support for mixed font sizes and additionally supports inline boxes for mixed media layout.
- Cosmic-Text has optimisations for lazily layouting very large documents with fixed line heights, which is useful for plain-text editing and terminal rendering use cases (which just happen to be core use cases for it's developers).
- They use different "font database" libraries in fontdb and fontique. Fontique has better support for loading system fonts and font fallback, but fontdb is better at being a "pure font database" into which you can load your own fonts. Ultimately neither are a complete solution and both need work. Both are also quite small libraries, and would be good candidates for a merging of projects.

CHECK:
There is one similarity between the stacks which is the Scaling/Hinting is 

## A vision for the future

- Agree on a font parsing library (probably skrifa/read-fonts)
- Merge fontdb and fontique (superset of functionality)
- Parley to switch to RustyBuzz/HarfRuzz
- Both stacks can move from Swash to Skrifa for scaling/hinting
- Potentially merge Cosmic-Text and Parley (or not).


----------------------------------------------------------------------------------------------------------------


  ====

  OLD

## Text libraries in Rust

### Servo

This meant:

- [Harfbuzz](https://github.com/harfbuzz/harfbuzz) for shaping on all platforms (through the [rust-harfbuzz](https://github.com/servo/rust-harfbuzz) bindings)
- Font enumeration, scaling/hinting and rasterisation being performed by the system-provided libraries (DirectWrite on Windows, CoreText on macOS/iOS, Freetype and FontConfig on Linux/Android) via [webrender](https://github.com/servo/webrender) and it's sub-crate [wr_glyph_rasterizer](https://github.com/servo/webrender/tree/main/wr_glyph_rasterizer)
- The Servo project has also published the [font-kit](https://github.com/servo/font-kit) crate for font enumeration / loading (using these same system libraries), however it is not really used by Servo itself anymore and is somewhat in maintenance mode.

Servo's high-level layout code is relatively sophisticated (supporting much of web's "inline layout"), but is tightly couple with the rest of Servo and not available as a standalone crate. Surprisingly, it is also missing important features such as BiDi resolution.


----

The Servo project was one of the first Rust projects with a need for high quality text rendering support. This was relatively early in Rust's development and the ecosystem was not nearly as strong as it is today so the approach they took was mostly to bind to pre-existing C libraries.

This meant:

- [Harfbuzz](https://github.com/harfbuzz/harfbuzz) for shaping on all platforms (through the [rust-harfbuzz](https://github.com/servo/rust-harfbuzz) bindings)
- Font enumeration, scaling/hinting and rasterisation being performed by the system-provided libraries:
  - DirectWrite on Windows
  - CoreText on macOS/iOS
  - Freetype and FontConfig on Linux/Android

The rasterisation (and scaling/hinting) step is wrapped in a unified API by the [wr_glyph_rasterizer](https://github.com/servo/webrender/tree/main/wr_glyph_rasterizer) crate which forms part of the [webrender](https://github.com/servo/webrender) engine which Servo shares with Firefox but is also usable indepedently. There is also unmerged [3rd-party work](https://github.com/declantsien/webrender/tree/emacs) that implements a pure-rust rasterization under this same API.

Text layout is done in Rust as part of the web engine (as part of a more general implementation of CSS "inline layout"), but is not exposed as an externally usable crate.

The Servo project does have a crate ([font-kit](https://github.com/servo/font-kit)) for font enumeration and fallback. But somewhat bizarely doesn't actually use it (except in a relatively small part of the canvas implementation). The code that Servo does primarily use for these tasks isn't exposed as a publically consumable crate.



The text functionality in their early projects such as Druid was based on system libraries, similar to Servo's. However, all of this changed, starting with Chad Brokaw [publishing](https://www.reddit.com/r/rust/comments/n16kod/swash_complex_text_shaping_and_glyph) the Swash and Parley crates in 2021. Swash is a "swiss army knife" crate that provides font parsing, unicode analysis, shaping, scaling/hinting, and rasterisation in a single package. Parley is similar to Cosmic-Text and provides integrates shaping, bidi analysis and high-level layout (with support for selection and editing under development). When linebender deprecated Driud and created Xilem they also abandoned their system-library based text engine in favour of one based on Swash and Parley.

The latest development is the [Fontations](https://github.com/googlefonts/fontations) project. This project is owned by Google Fonts, with the goal of moving all of Google's shaping, rasterization, font compilation, and general font inspection and manipulation from Python & C++ to Rust (how far down that route they go remains to be seen). Important projects from a Rust UI perspective include:

- `read-fonts` this is low-level OpenType font parsing library that uses auto-generated code for each OpenType "table". It designed to be both fast (zero-copy) and correct.
- `skrifa` builds on top of `read-fonts` and adds higher level APIs including scaling and hinting (TrueType hinting, CFF hinting, and autohinting). `skrifa` aims to be a complete replacement for Freetype, and is in the process of being [rolled out as such in Chromium](https://groups.google.com/a/chromium.org/g/blink-dev/c/4xUt73fxCrU). https://chromestatus.com/feature/5717358869217280 
- [harfruzz](https://github.com/harfbuzz/harfruzz) is fork of RustyBuzz which ports it to use `skrifa`/`read-fonts` instead of `ttf_parser` as the underlying font parsing library. This work is also sponsored by Google Fonts and there are plans to:
  - Port performance optimisations from HarfBuzz
  - Potentially incorporate some of the improvements from Swash's shaper that could allow for faster font fallback.


Skrifa and Harfruzz can in many ways be seen as the sucessors to the scaling/hinting and shaping parts of Swash, with Chad Brokaw (who wrote `swash`) now working at Google Fonts and being heavily involved in the development of both libraries (and some code being directly adapted from `swash`).

In addition to these libraries, Linebender's 2D rendering library Vello has support for GPU-acelerated rasterization of fonts from vector outlines, which can be generated by either Swash or Skrifa (or Freetype).
