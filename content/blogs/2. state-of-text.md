---
title: "SoRUI #1 - The State of Rust Text Rendering 2024"
date: 11 Aug 2024
description: ' '
tags: ['rust', 'ui', 'text', 'fonts']
published: false
---

This post is the first in a new series of "State of Rust UI" (SoRUI) blog posts. Each post in the series focusses on a different theme with Rust UI. The theme of this post is text rendering.

<small>Readers of this article may also be interested in this [State of Text Rendering 2024](https://behdad.org/text2024/) article by Behdad Esfahbod (HarfBuzz maintainer) which covers recent developments in text rendering more widely but has less detail about the state of the Rust ecosystem specifically.</small>

## Understanding The Modern Text Rendering Pipeline

Text rendering is surprisingly complex.

In 2024 it isn't sufficient to only handle Latin scripts (let alone only ASCII text). We need to handle Arabic that runs right-to-left rather than left-to-right. We need to handle Chinese and Japanese scripts which can be run vertically as well as horizontally. We need to handle Indic scripts which have complex rules for reordering glpyhs.

We also need to be able to handle arbitrary combinations of such scripts (potentially mixing multiple fonts and writing directions), with emoji which also typically come with their own dedicated fonts (for which there are several competing formats in mainstream use). We need to handle ligatures. We need to deal with variable fonts. The list goes on.

A modern text rendering pipeline involves roughly the following steps:

* **Font Parsing** Parsing of font formats. Most fonts use the OpenType format. However, OpenType is really a meta/container format that may contain several different "tables" (which may contain arbitrary binary data), each identified by a 4-byte tag. In order to fully support a modern text stack you need to be able to parse not only the tradtional tables representing TrueType font data, hinting and ligatures, but also tables representing Apple's AAT fonts (and their different hinting format), both COLR and 
* **Font enumeration** is listing (enumerating) all the fonts installed on the system. And collecting metadata about those fonts, for example whether they are serif, sans-serif, monospace, their weight, the code points they cover, etc. Such libraries will typically also load the full font into memory as required (often using mmap).
* **Font fallback** is matching runs of text to a font. This is necessary because fonts typically don't cover the entire unicode range: you have different fonts for latin text, chinese text, arabic text, etc and also usually a separate font for emoji. But if you have say arabic text or emoji embedded within latin text you don't typically specify the font for the arabic text or the emoji, one is chosen for you. That process is font fallback.
* **Clustering** is the combining unicode code points into "shaping clusters" in preparation for shaping. [Shaping clusters](https://harfbuzz.github.io/clusters.html) are distinct from [Grapheme Clusters](https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries) and are generally (always?) made up of 1 or more grapheme clusters. Clustering and font-fallback are often closely coupled with shaping in current implementations (e.g. Harfbuzz), but future implementations may be able to decouple them.
* **Shaping** means mapping runs of unicode codepoints (shaping clusters) to specific glyphs within fonts. This includes simple mappings like mapping the "a" character to the appropriate "a" glyph, but also involves things like applying ligatures and resolving emoji modifiers. Some scripts (notably some Indic scripts) require much more complex transformations that involve reordering characters within a cluster.
* **Layout** is computing x/y coordinates for each glyph in a string of text. This includes things like determining a glyph's size (and the appropriate offset for that glyph relative to the previous glyph), line breaking, and bidi reordering. It can also includes more advanced capabilities such as mixed media layout (placing images or other boxes inline with text), laying out around excluded areas, floated boxes. And even things like following an arbitrary vector path.
* Scaling / Hinting
* Rasterisation

Bonus: selection, editing, IME, subsetting, unicode processing

## Text libraries in Rust

### Servo

The Servo project was one of the first Rust projects with a need for high quality text rendering support. This was relatively early in Rust's development and the ecosystem was not nearly as strong as it is today so the approach they took was mostly to bind to pre-existing C libraries.

This meant:

- [Harfbuzz](https://github.com/harfbuzz/harfbuzz) for shaping on all platforms (through the [rust-harfbuzz](https://github.com/servo/rust-harfbuzz) bindings)
- Font enumeration, scaling/hinting and rasterisation being performed by the system-provided libraries:
  - DirectWrite on Windows
  - CoreText on macOS/iOS
  - Freetype and FontConfig on Linux/Android

The rasterisation (and scaling/hinting) step is wrapped in a unified API by the [wr_glyph_rasterizer](https://github.com/servo/webrender/tree/main/wr_glyph_rasterizer) crate which forms part of the [webrender](https://github.com/servo/webrender) engine which Servo shares with Firefox but is also usable indepedently. There is also unmerged [3rd-party work](https://github.com/declantsien/webrender/tree/emacs) that implements a pure-rust rasterization under this same API.

Text layout is done in Rust as part of the web engine (as part of a more general implementation of CSS "inline layout"), but is not exposed as an externally usable crate.

The Servo project does have a crate ([font-kit](https://github.com/servo/font-kit)) for font enumeration and fallback. But somewhat bizarely doesn't actually use it (except in a relatively small part of the canvas implementation). The code that Servo does primarily use for these tasks isn't exposed as a publically consumable crate.

### Resvg and Cosmic-Text

[Resvg](https://github.com/RazrFalcon/resvg) is another Rust project which has spawned a very impressive set of text-rendering crates. Which is made all the more impressive by the fact that the bulk of the work on them was done by a single person - Yevhenii Reizner ([@RazrFalcon](https://github.com/RazrFalcon)), although there have also been notable contributors including Laurenz Stampfl ([@LaurenzV](https://github.com/LaurenzV)) from the [Typst](https://github.com/typst/typst) project.

The key text-related crates associated with the resvg project are:

- [ttf-parser](https://github.com/RazrFalcon/ttf-parser) which is a hand-written parser for TrueType and OpenType font files.
- [rustybuzz](https://github.com/RazrFalcon/rustybuzz) which is Rust port of Harfbuzz's shaping functionality. Rustybuzz is up to date with the latest version of Harfbuzz, and passes it's entire test suite.
- [fontdb](https://github.com/RazrFalcon/fontdb) which is a simple font database.

Building on top of these crates (and swash - which we will get to in a minute - for rasterisation) is [cosmic-text](https://github.com/pop-os/cosmic-text) which provides high-level layout, selection and editing.

### Linebender / Fontations

[Linebender](https://linebender.org) is an open-source collective focussed on creating tools for 2D graphics and user interfaces in Rust. Linebender as an organisation has a lot of expertise in text, being started by [Raph Levien](https://levien.com/) who currently works at Google Fonts previously maintained Android's text stack and designed the [Inconsolata fonts](https://levien.com/type/myfonts/inconsolata.html), and having attracted a number of other contributors who also have deep expertise in text.

However, all of this changed, starting with Chad Brokaw [publishing](https://www.reddit.com/r/rust/comments/n16kod/swash_complex_text_shaping_and_glyph) the Swash and Parley crates in 2021. Swash is a "swiss army knife" crate that provides font parsing, unicode analysis, shaping, scaling/hinting, and rasterisation in a single package. Parley  but the two really 

The font parsing and scaling/hinting code in Swash has been / is being productionised as 3 separate crates as of part of the Fontations project under Google Fonts ownership.

- swash
- parley
- fontique
- fontations: read_fonts/write_fonts/skrifa
- harfruzz
- vello

### Other

- Allsorts
- ab_glyph
- fontdue
- Makepad
- Bevy
- Skia


# Unicode text handling

Rust, being a new language, is at an advantage in that it's standard library types (such as `String`) represent text as UTF-8. So basic text storage and processing is covered.

However, there are a number of more specific unicode handling routines and algorithms (normalization, segmentation, etc) that are not included in `std` that require an external library. There are two main sets of crates for this in the Rust ecosystem:

- The `unicode-*` crates. These were some of the earlier unicode handling crates in Rust and are widely used.
- The `icu4x` crates. These are a official Unicode Consortium project.

There is also `xi-unicode`, but it is effectively in maintenance mode, with the linebender organisation who created it looking to move to the `icu4x` crates.

In general the `icu4x` crates are more correct/complete, but the `unicode-*` crates are still pretty good and may be faster / more lightweight. For example, the `icu_segmentation` crate offers dictionary-based word segmentation for the Thai language (which doesn't seperate words using spaces) which is important for segmenting Thai but comes at the cost of including the dictionary data. It also offers customisations for different CSS line-breaking modes. Whereas `unicode-segmentation` doesn't offer either of these options but does otherwise correctly implement the unicode segmentation algorithms.

I would suggest defaulting to the icu crates.

# Parsing

- Freetype / Harfbuzz
- ttf_parser
- read-fonts/skrifa
- System libs?

# Font Databases: Enumeration & Querying

There are 3 main crates which do font enumeration in the Rust ecosystem:

- font-kit
- fontdb
- fontique

Font-kit is different from the other two in that it allows fonts to be loaded as handles to the system libraries' (DirectWrite, CoreText and Freetype) native font representations.

Both `fontdb` and `fontique` have standardised on `Arc<dyn AsRef<[u8]> + Send + Sync>` as the underyling type for raw font data. Which (in both cases) is backed by either a memory mapped file (for system fonts) or a `Vec<u8>` if in-memory font data is loaded by the user. And more than any other part of the ecosystem these libraries are excellent candidates for a merging of projects.

The main differences between the two libraries are:

The font enumeration methods:

- Fontdb uses simple filesystem scanning with hardcoded directories. This has the advantage of being simple and lightweight, but the disadvantage of being incompatible with what other appplications on a user's system do which can lead to fonts not being picked up. 
- Fontique hooks into the system-provided mechanisms for enumeration, falling back to scanning where these are inadequate or not available. This has the advantage of matching system norms at the cost of having to depend on relatively heavy system libraries.

And the underlying font parsing library:

- Fontdb uses `ttf_parser`.
- Fontique uses `read_fonts`+`skrifa`

However, it should be relatively easy to merge the enumeration methods by implementing a superset and making use of feature-flagging to allow end-users to make their own trade-offs regarding dependency weight and enumeration fidelity.

Regarding the font parsing library, ideally there should only be one. However, neither library's use of font parsing is that widespread, so it came to it then this could also be abstracted into feature-flagged backends.

The motivation for enacting a merge is interoperability. Many text/font-related activities can be performed independently (so it would be relatively easy for the ecosystem to support multiple options that could be mixed and matches). However, they almost all require a database of fonts and that database really ought to be a global resource that is only loaded once to keep memory usage low. And a single, agreed-upon font database library would make interoperability between the various libraries much smoother.



# Clustering, Shaping & Fallback

- Harfbuzz
- Rustybuzz
- Harfruzz
- Swash
- Allsorts

# Layout, Selection & Editing

- Cosmic-Text
- Parley
- (+ something (winit?) for IME)

# Scaling, Hinting & Rasterisation

- System libs: wr_glyph_rasterizer
- Freetype
- Swash/Zeno
- Skrifa
- Path rasteriser:
  - Tiny-SKia
  - Vello
  - Skia
  - Etc
